package Theory;

public class SecondModule {
    import java.util.ArrayList;
import java.util.List;

    public class Review2 {
    }
//      Что такое ООП? В чем его плюсы?
/*
        Объектно-ориентированное программирование (ООП) — это подход, при котором программа рассматривается
        как набор объектов, взаимодействующих друг с другом. У каждого есть свойства и поведение.

        Плюсы ООП:
        1. структурированная информация не допускает путаницы;
        2. точно определяет взаимодействие одних элементов с другими;
        3. повышает управляемость программы;
        4. код быстрее масштабируется под различные задачи;
        5. позволяет лучше понимать написанное и эффективнее поддерживать готовые программы;
        6. изменения внедряются без необходимости переписывать весь код.
*/

//      Перечислите основные принципы ООП
/*
        Объектно-ориентированное программирование определяют через четыре принципа,
        по которым можно понять основы работы:
        1. Инкапсуляция
        2. Полиморфизм
        3. Наследование
        4. Абсракция
 */

//      Что такое инкапсуляция? Приведите пример инкапсуляции?
/*
        Инкапсуляция
        Скрытие внутренней реализации объекта от внешнего мира.
        Это означает, что данные и методы, которые оперируют с этими данными, объединяются в единое целое,
        называемое классом. Внешний код может взаимодействовать с объектом только через определенные методы,
        предоставленные классом, не имея прямого доступа к его внутренним данным.

        Пример инкапсуляции: приватные поля и методы в классе.

            //---Преимущества принципа инкапсуляции---//

            1. Безопасность данных.
            Инкапсуляция позволяет защитить данные объекта от некорректного доступа и изменения извне.

            2. Сокрытие реализации.
            Когда класс инкапсулирует свою реализацию, то изменения внутри класса не отражаются на внешнем коде.

            3. Упрощение интерфейса.
            Инкапсуляция позволяет предоставить простой и понятный интерфейс для работы с объектами.
            Клиентский код взаимодействует только с публичными методами класса, не требуя знания деталей
            его внутренней реализации.

            4. Модульность.
            Инкапсуляция помогает создавать модульные системы, где каждый класс представляет собой отдельный модуль
            со своими данными и методами.

            5. Принцип единственной ответственности.
            Класс, инкапсулирующий определенные данные и операции с ними, должен отвечать только за эти данные
            и их обработку.

            6. Контроль доступа.
            Инкапсуляция ООП позволяет устанавливать уровни доступа к данным и методам класса.
 */

//      Что такое полиморфизм? Приведите пример полиморфизма?
/*
        Полиморфизм
        Концепция, позволяющая создавать более гибкие, расширяемые и понимаемые программы.
        Полиморфизм в контексте ООП означает, что разные объекты могут реагировать на один и тот же запрос,
        проявляя разное поведение в зависимости от своего типа.

        Пример полеморфизма: перегрузка методов / переопределение методов для классов наследников / реализация интерфейса

            //---Преимущества принципа полиморфизма---//

            1. Гибкость и расширяемость.
            Позволяет добавлять новые типы объектов и операций без изменения существующего кода.

            2. Упрощение кода.
            Способствует уменьшению дублирования кода. Общий интерфейс или абстрактный базовый класс позволяют описать
            общее поведение, и каждый конкретный класс реализует только свою специфичную логику.

            3. Читаемость кода.
            Полиморфизм делает код более интуитивно понимаемым, так как работа с различными объектами происходит
            через общий интерфейс.

            4. Расширение функциональности.
            Добавление новых функций или операций для существующих классов становится проще.

            5. Повторное использование кода.
            Полиморфизм позволяет использовать одни и те же методы для разных типов данных.

            6. Улучшение тестирования.
            Тестирование становится более удобным, так как можно создать общие тестовые сценарии для всех классов,
            реализующих один интерфейс.

            7. Облегчение командной разработки.
            Когда разработчики работают над разными частями программы, полиморфизм позволяет им взаимодействовать
            через общие интерфейсы без необходимости глубокого понимания внутренней реализации друг друга.
*/

//      Что такое наследование? Приведите пример наследования? Зачем оно нужно?
/*
        Наследование
        Позволяет создавать иерархии классов, где один класс (подкласс) наследует свойства и методы
        другого класса (суперкласса). Это позволяет сокращать дублирование кода, упрощать структуру программы
        и создавать более логичные иерархии объектов.

        Пример наследования:
        один класс наследуется от другого, при этом сохраняя или переопределяя реализацию его методов и добавляя новые.
        Это нужно для расширения функционала.

            //---Преимущества принципа наследования---//

            1. Повторное использование кода.
            Наследование позволяет создавать иерархии классов, где общая функциональность реализуется
            в родительском классе, и все подклассы автоматически наследуют этот код.

            2. Расширяемость.
            Принцип наследования позволяет создавать новые классы, расширяющие функциональность существующих классов.

            3. Упрощение кода.
            Использование наследования позволяет разбивать большие и сложные классы на более мелкие и управляемые части.

            4. Полиморфизм.
            Наследование поддерживает концепцию полиморфизма, которая позволяет обращаться к объектам подклассов
            через ссылки на родительские классы.

            5. Абстракция.
            Наследование позволяет выделить общие характеристики объектов и создать абстрактные классы,
            которые определяют интерфейс для группы связанных классов.

            6. Структурирование кода.
            Наследование помогает упорядочить классы в логические иерархии, что улучшает структуру программы.
*/
/*
        4. Абстракция
        Процесс выделения общих характеристик и функциональности объектов или системы, игнорируя детали реализации.
        Абстракция позволяет разрабатывать программы на различных языках программирования,
        скрывая сложность и детали нижележащего кода.

            //---Преимущества абстракции---//

            1. Упрощение сложности.
            Абстракция в программировании позволяет скрыть детали реализации
            и сосредоточиться на ключевых аспектах системы.

            2. Модульность.
            Возможность разбить систему на модули или классы, которые могут работать независимо друг от друга.

            3. Повышение безопасности.
            Абстракция позволяет скрыть некоторые детали реализации, что делает код более безопасным и защищенным.
 */

//      Что такое класс? Объект?
//      Как передаются объекты в метод?
/*
        Класс — модель для создания объектов определённого типа, описывающая их структуру
        (набор полей и их начальное состояние) и определяющая алгоритмы (функции или методы) для работы с этими объектами.

        Объект — это экземпляр класса.

        Чтобы передать объект в метод, необходимо использовать его в качестве аргумента метода.
*/

//      Что такое переопределение метода в Java?
//      Что такое перегрузка метода в Java?
/*
        Переопределение метода - одна из возможностей языка программирования, позволяющая подклассу или дочернему классу
        обеспечивать специфическую реализацию метода, уже реализованного в одном из суперклассов или родительских классов.

        Перегрузка метода — это использование одного имени метода с разными параметрами.
*/

//      Что такое нативные методы, их плюсы и минусы?
/*
        Нативные методы.
        Ключевое слово native в Java используется для объявления нативных методов, то есть методов, которые реализованы
        на другом языке программирования. Это позволяет разработчикам использовать функции и возможности,
        которые не доступны или неэффективны в Java.

            //---Плюсы использования native метода---//

            1. Более высокая производительность.
            Использование native методов позволяет использовать оптимизированный код на других языках программирования,
            что может привести к улучшению производительности приложения.

            2. Доступ к системным ресурсам.
            Native методы могут предоставлять доступ к системным функциям и ресурсам, таким как файловая система или сеть.
            Это особенно полезно при разработке приложений с высокими требованиями к взаимодействию с операционной системой.

            3. Использование сторонних библиотек.
            Native методы позволяют использовать функционал, доступный только через сторонние библиотеки,
            написанные на других языках программирования.

            //---Минусы использования native метода---//

            1. Сложность отладки и тестирования.
            Использование native методов делает отладку и тестирование приложения сложнее, так как ошибки в коде
            на другом языке программирования могут быть сложнее обнаружить и исправить.

            2. Зависимость от платформы.
            Native методы могут быть зависимы от конкретной платформы, что может создавать проблемы при портировании
            приложения на другую операционную систему.

            3. Ограничения безопасности.
            Native методы имеют прямой доступ к системным ресурсам, что может создавать риски безопасности,
            если неправильно используются.
            Поэтому необходимо тщательно проверять и контролировать использование native методов.
*/

//      Что такое метод и чем отличается от функции, возвращаемое значение, аргументы метода?
/*
        Метод — это функция, связанная с определенным объектом или классом. Метод обрабатывает данные объекта
        и изменяет их состояние. Он имеет доступ к свойствам объекта и может вызываться только для конкретного
        экземпляра класса. Методы обычно являются частью интерфейса класса и служат для выполнения определенных
        действий с данными.

        Преимущества методов в том, что они могут взаимодействовать с состоянием объекта
        и иметь различные доступы к его данным. Они также удобны для работы с классами и обеспечивают инкапсуляцию.
        Однако методы могут быть доступны только через объект класса, что может быть неудобно в некоторых ситуациях.

        Функция — это блок кода, который может принимать входные параметры и возвращать результат.
        Обычно используются для выполнения определенного действия или вычисления значения. Они могут быть вызваны
        из любого места программы и могут быть использованы повторно в различных контекстах.

            //---Основные различия между методом и функцией включают следующее---//

            1. Контекст вызова.
            Метод является частью класса или объекта, и имеет доступ к его свойствам и методам.
            Функция, с другой стороны, не привязана к классу или объекту и может быть вызвана независимо.

            2. Передача аргументов.
            Методы обычно принимают неявный первый аргумент, который представляет собой ссылку на сам объект,
            к которому они принадлежат.
            Функции могут принимать аргументы в любом количестве и не связаны с каким-либо объектом.

            3. Создание и вызов.
            Методы должны быть созданы внутри класса или объекта, прежде чем они могут быть вызваны.
            Функции могут быть созданы в любом месте программы и вызываться по необходимости.

            4. Возвращаемое значение.
            Методы могут возвращать значение или не возвращать его вообще.
            Функции обычно возвращают значение в конце своего выполнения.

        //---Когда использовать методы---//

        Выполнение повторяющихся действий.
        Если требуется выполнить одно и то же действие несколько раз,то метод позволяет изолировать эту логику
        и вызывать его по мере необходимости. Это упрощает кодирование и обновление программы.

        Абстрагирование сложных операций.
        Методы позволяют скрывать сложную логику и предоставляют более простой интерфейс для работы с объектом.
        Это снижает сложность кода и упрощает его понимание.

        Модульность.
        Методы помогают разбить программу на более мелкие и независимые части, которые могут быть легко тестированы
        и поддерживаемы. Это упрощает разработку и повышает переиспользуемость кода.


        //---Когда использовать функции---//

        Повторяющиеся операции.
        Если вам нужно выполнять одну и ту же последовательность операций несколько раз, вы можете поместить
        эту последовательность в функцию и вызывать ее при необходимости.
        Это позволяет избежать дублирования кода и упрощает его поддержку и обслуживание.

        Упрощение сложных задач.
        Функции позволяют разбить сложные задачи на более мелкие подзадачи. Каждая функция может быть ответственна
        только за выполнение своей конкретной задачи, что делает код более читаемым и поддерживаемым.
        Кроме того, при изменении требований вам нужно будет изменить только одну функцию, а не всю программу целиком.

        Легкость отладки.
        Если ваш код разбит на функции, вы можете легко отслеживать и исправлять ошибки. Если ошибка возникает в функции,
        вы знаете, где искать проблему, и можете сосредоточиться на той части кода, которую она затрагивает.

        Повторное использование.
        Функции позволяют повторно использовать код в разных частях программы. Если вам нужно выполнить определенную
        операцию в нескольких местах, вы можете вынести эту операцию в функцию и вызывать ее из разных мест.
        Это экономит время и усилия при разработке и обслуживании программы.
*/

//      Какие модификаторы доступа могут быть у класса?
/*
        В Java существует четыре модификатора доступа, которые ограничивают видимость и доступ к классам,
        переменным, методам и конструкторам.

        1. Public
        Элемент доступен из любого места в программе, включая другие пакеты.

        2. Protected
        Элемент доступен только для классов из того же пакета и всех подклассов. Это полезно, когда нужно предоставить
        доступ к определенным методам и переменным для наследников, но скрыть их от других классов.

        3. Default (Модификатор доступа по умолчанию)
        Если модификатор доступа не указан явно, то используется уровень доступа по умолчанию,
        который также называется «пакетный доступ».
        Элементы с таким уровнем доступа доступны только для классов из того же пакета, что и определенный элемент.

        4. Private
        Модификатор private делает элемент доступным только внутри класса, в котором он определен.
        Это наиболее ограничительный уровень доступа и используется для инкапсуляции и скрытия деталей реализации.
*/

//      Как реализована неизменность String?
/*
        Неизменность строк достигается путем хранения строк в виде массива символов ( char[] ),
        который является неизменяемым объектом.
        При изменении строки создается новый массив символов с новым значением строки.

        Как и другие классы-обертки в Java, класс String является иммутабельным.

        //---Иммутабельность строк дает следующие преимущества---//

            1. Строки потокобезопасны.

            2. Для строк можно использовать специальную область памяти, называемую "пул строк". Благодаря которой
            две разные переменные типа String с одинаковым значением будут указывать на одну и ту же область памяти.

            3. Строки отличный кандидат для ключей в коллекциях, поскольку они не могут быть изменены по ошибке.

            4. Класс String кэширует хэш-код, что улучшает производительность хеш-коллекций, использующих String.

            5. Чувствительные данные, такие как имена пользователей и пароли, нельзя изменить по ошибке
            во время выполнения, даже при передаче ссылок на них между разными методами.
*/

    //      Как реализовать свой Immutable тип данных?
/*
        Иммутабельный (неизменяемый, immutable) класс — это класс, который после инициализации
        не может изменить свое состояние. То есть если в коде есть ссылка на экземпляр иммутабельного класса,
        то любые изменения в нем приводят к созданию нового экземпляра.

            //---Чтобы класс был иммутабельным, он должен соответствовать следующим требованиям---//

            1. Должен быть объявлен как final, чтобы от него нельзя было наследоваться.
            Иначе дочерние классы могут нарушить иммутабельность.
            (Сделать класс final)

            2. Все поля класса должны быть приватными в соответствии с принципами инкапсуляции.
            (Сделать все поля private)

            3. Для корректного создания экземпляра в нем должны быть параметризованные конструкторы,
            через которые осуществляется первоначальная инициализация полей класса.
            (Не создавать конструктор по умолчанию)

            4. Для исключения возможности изменения состояния после инстанцирования, в классе не должно быть сеттеров.
            (Не создавать сеттеры для полей)

            5. Для полей-коллекций необходимо делать глубокие копии, чтобы гарантировать их неизменность.

            6. В конструкторе с параметрами и геттерах проводить глубокое копирование получаемого/передаваемого объекта.

        Хотя использование иммутабельных объектов дает преимущества, но их использование не всегда оправдано.
        Обычно нам нужно как создавать объекты, так и модифицировать их для отражения изменений, происходящих в системе.

        То есть нам нужно изменять данные, и нелогично создавать новые объекты при каждом изменении,
        так как это увеличивает используемую память, а мы хотим разрабатывать эффективные приложения и оптимально
        использовать ресурсы системы.
*/
    final class ImmutableList {
        private List<String> list;

        ImmutableList(List<String> listValue) {
            list = new ArrayList<>();
            for (String item : listValue) {
                list.add(item);
            }
        }

        public List<String> getList() {
            List<String> listValue = new ArrayList<>();
            for (String item : list) {
                listValue.add(item);
            }
            return listValue;
        }
    }
    class App {
        public static void main(String[] args) {
            List<String> list = new ArrayList<>(List.of("1", "2", "3"));
            ImmutableList immutableList = new ImmutableList(list);

            list.add("4");
            System.out.println(list); // => [1, 2, 3, 4]
            System.out.println(immutableList.getList()); // => [1, 2, 3]

            List<String> testList = immutableList.getList();
            testList.add("5");
            System.out.println(testList); // => [1, 2, 3, 5]
            System.out.println(immutableList.getList()); // => [1, 2, 3]
        }
    }

//      Что такое ключевое слово static?  Что может быть static?
//      Могут ли нестатические методы перегрузить статические?
/*
        static — модификатор, применяемый к полю, методу или внутреннему классу.
        Данный модификатор указывает на привязку субъекта к текущему классу.

            static поля относятся к классу и имеют одинаковое значение для всех объектов этого класса.
        (Пример Animal.count -> считает количество созданных animal)

            static методы отличаются от обычных тем, что они также привязаны к классу, а не к объекту.
        (Пример Animal.getCount - статический метод, относящийся напрямую к классу,
        animal.setName("Name") - нестатический метод, который взаимодействует с нестатическим полем Класса).
        Важным свойством статического метода является то, что он может обратиться только к статическим переменным/методам.

        Нестатические методы не могут перегрузить статические методы в Java. Это связано с тем, что статические методы
        связаны с классом, в то время как нестатические методы связаны с экземпляром класса.

            static классом может быть только внутренний класс.
        Опять же, этот класс привязан к внешнему классу, и если внешний наследуется другим классом,
        то этот не будет наследован. При этом данный класс можно наследовать, как и он может наследоваться
        от любого другого класса и имплементировать интерфейс.
*/

//      Что такое пакет? Как создать пакет?
/*
        Пакеты используются для организации классов и интерфейсов в логические группы.
        Пакеты позволяют избежать конфликтов имен и упрощают структуру проекта.

        Чтобы создать пакет в Java, вы можете включить декларацию пакета в верхней части файла с исходным кодом.
        Например, если вы хотите создать пакет с именем "myPackage", ваши файлы с исходным кодом могут выглядеть так:

        package myPackage;

        public class MyClass {
            // код класса
        }

*/

//      Что такое конструкторы? Конструктор по-умолчанию?
/*
        Конструктор - это специальный метод, позволяющий инициализировать начальное состояние класса
        при создании его экземпляра.

        Конструктор по умолчанию — конструктор, который может быть вызван без аргументов.
*/

//      Расскажи, что такое this и super? Когда мы обязаны использовать this и super?
/*
        Ключевое слово "this" используется для обращения к текущему объекту из метода класса.
        Оно может использоваться для доступа к полям и методам объекта внутри самого класса.

            //---Ключевое слово "this" обычно используется в следующих случаях---//

            1. Для разрешения неоднозначности между локальными переменными и полями объекта.
            Например, чтобы указать, что вы обращаетесь к полю объекта, а не к локальной переменной,
            используйте "this.fieldName".

            2. Для вызова одного конструктора из другого в том же классе.

            3. Для передачи объекта в качестве аргумента в другой метод.

            4. Для возврата текущего объекта из метода.

        Ключевое слово "super" используется для обращения к членам родительского класса из подкласса.
        Оно позволяет вызывать конструктор родительского класса, обращаться к полям и методам родительского класса.

            //---Ключевое слово "super" обычно используется в следующих случаях---//

            1. Для вызова конструктора родительского класса из конструктора подкласса.

            2. Для обращения к методам родительского класса, если в подклассе метод имеет тот же самый идентификатор.
 */

//      Класс Object и все методы кроме wait, notify, notifyAll
/*
        В Java, класс Object является корневым классом для всех других классов.
        Это означает, что любой объект в Java является экземпляром класса Object, непосредственно или косвенно.

            //---Методы класса---//

            1 getClass(): Возвращает объект типа Class, который представляет класс объекта.

            2 equals(Object obj): Определяет, равен ли указанный объект текущему.

            3 hashCode(): Возвращает хэш-код объекта.

            4 toString(): Возвращает строковое представление объекта.

            5 finalize(): Вызывается сборщиком мусора для объекта, когда сборщик мусора определяет,
            что ссылок на объект больше нет.
            Подкласс переопределяет finalize метод для удаления системных ресурсов или выполнения другой очистки.

            6 clone(): Создает и возвращает копию объекта.
 */

//      Зачем нужен метод finalize?
/*
        Метод finalize() в Java был предназначен для выполнения определенных действий перед тем,
        как объект будет собран сборщиком мусора. Это могло быть использовано для освобождения ресурсов,
        закрытия файлов, освобождения памяти и т.д.
        Однако, следует отметить, что метод finalize() имеет несколько ограничений и проблем,
        из-за чего он устарел и не рекомендуется к использованию.

        Одной из основных проблем метода finalize() является то, что его вызов не гарантирован,
        и неизвестно, когда именно сборщик мусора выполнит этот метод.
        Это может привести к неэффективному использованию ресурсов и памяти.

        Вместо использования finalize(), в Java рекомендуется явно освобождать ресурсы и проводить очистку в коде
        с помощью методов, предоставленных языком, таких как close() для закрытия ресурсов, например, файловых потоков
        или сетевых соединений.

        Итак, в современной Java использование метода finalize() не рекомендуется из-за его ненадежности
        и потенциальных проблем, и вместо этого рекомендуется явно управлять ресурсами в коде.
 */

//      Из-за чего происходят коллизии?
/*
        В контексте хэш-таблиц, коллизия происходит, когда два различных ключа после применения функции хеширования
        дают один и тот же хэш-код.

        Это может произойти из-за ограниченного размера массива, в котором хранятся элементы,
        или из-за плохо спроектированной функции хеширования.

        Коллизии могут привести к ситуации, когда различные ключи должны быть помещены в одну и ту же "ячейку" массива,
        что затем требует дополнительной логики для разрешения конфликтов.

        Для предотвращения или разрешения коллизий в хэш-таблицах обычно используются такие методы,
        как метод цепочек (открытое хеширование) или метод открытой адресации.
 */

//      В чём разница между instanceOf и getClass?
/*
        instanceof используется для проверки, является ли объект экземпляром определенного класса или его суперкласса.
        Например, если у вас есть объект типа Dog, вы можете проверить, является ли он экземпляром класса Animal

        getClass() вызывается на конкретном объекте и возвращает объект типа Class, представляющий тип этого объекта.
        Например, если у вас есть объект типа String, вызов метода getClass() на этом объекте вернет объект типа Class,
        представляющий класс String.
        Метод getClass() помогает получить информацию о типе объекта во время выполнения программы.
        Это полезно, когда нужно определить тип объекта и выполнить определенные действия.

        Оператор instanceof проверяет, является ли объект экземпляром определенного класса или его подкласса
        в момент выполнения программы, в то время как метод getClass() используется для получения информации
        о типе конкретного объекта в момент выполнения.
*/

//      Перечислите методы именно класса Enum?
/*
        1 name() - возвращает имя перечисления
        2 ordinal() - возвращает порядковый номер константы в объявлении перечисления
        4 valueOf(String name) - возвращает enum-константу с указанным именем
        5 values() - возвращает массив значений перечисления

        6 toString() - возвращает строковое представление перечисления
        3 compareTo(Enum e) - сравнивает этот enum с другим enum
 */

//      Что такое интерфейс? Когда использовать интерфейс?
//      Можно ли создать поля в интерфейсе?
/*
        Интерфейс в Java представляет собой абстрактный тип, который используется для определения методов,
        но не их реализации. Он содержит только сигнатуры методов, но не их тела.
        Классы могут реализовывать интерфейсы, предоставляя конкретную реализацию методов, определенных в интерфейсе.

            //---Интерфейсы обычно используются в следующих случаях---//

            1. Для достижения множественного наследования.
            В Java класс может наследовать только один класс, но он может реализовывать несколько интерфейсов,
            что позволяет классу иметь поведение, определенное в различных интерфейсах.

            2. Для реализации "контракта".
            Интерфейсы используются для определения обязательств, которые класс должен выполнить.

            Интерфейсы также применяются в различных архитектурных паттернах, таких как слушатели событий.

        Начиная с Java 8, в интерфейсах можно создавать статические поля и даже дефолтные методы.
        Поля в интерфейсе должны быть явно определены как public, static и final.
        Они являются константами и должны быть инициализированы. Это позволяет использовать интерфейсы для определения
        общих констант, которые могут быть использованы в классах, которые реализуют интерфейс.

        Также, начиная с Java 9, в интерфейсах можно использовать private методы,
        чтобы объединить общую логику, которая требуется нескольким методам интерфейса.
        Однако private поля нельзя объявить в интерфейсе.
 */

//      Есть ли в Java множественное наследование? Зачем реализовывать интерфейс интерфейсу?
/*
        В Java классы не поддерживают множественное наследование, то есть класс не может наследоваться напрямую
        от нескольких классов. Однако, в Java есть возможность реализации множества интерфейсов.
        Это означает, что класс может реализовывать несколько интерфейсов, что предоставляет ему возможность
        "унаследовать" поведение от нескольких различных источников.

        Реализация интерфейса интерфейсу может быть полезна в случае, если один интерфейс расширяет другой интерфейс
        путем добавления новых методов, что может быть полезно для организации кода, предоставляя гибкость в определении
        иерархии интерфейсов и их взаимосвязей.
 */

//      Можно ли создавать статик методы в интерфейсах?
/*
        Начиная с Java 8, интерфейсы могут содержать статические методы.
        Статические методы в интерфейсах предоставляют некоторые общие функциональности
        для всех классов, реализующих данный интерфейс.

        Классы, реализующие этот интерфейс, могут использовать эти методы напрямую, не создавая экземпляр интерфейса.
            Объект интерфейса - это экземпляр, созданный на основе интерфейса. Объект интерфейса не создается напрямую,
            потому что интерфейсы сами по себе не имеют реализации.
            Однако классы, реализующие интерфейсы, могут рассматриваться как объекты этого интерфейса.
            Таким образом, когда говорят "создать объект интерфейса", обычно имеют в виду создание экземпляра класса,
            реализующего этот интерфейс.

        Использование статических методов в интерфейсах предоставляет удобный способ организации кода и предоставления
        общих утилитарных методов для всех классов, связанных с этим интерфейсом.
 */

//      Что такое абстрактный класс? Чем отличается от обычного?
//      Что такое абстрактный метод?
/*
        Абстрактный класс - это класс-шаблон, объект которого нельзя создать напрямую.
        Он предназначен для использования в качестве родительского класса для других классов.

        Абстрактные классы могут содержать как реализованные, так и абстрактные методы,
        которые должны быть переопределены в подклассах.

        Отличие абстрактного класса от обычного в том, что абстрактный класс может содержать абстрактные методы,
        то есть методы без тела или реализации, в то время как обычные классы содержат только реализованные методы.
        Также, в отличие от обычного класса, у абстрактного класса не может быть создан экземпляр непосредственно.

        Все абстрактные методы должны быть реализованы в подклассах абстрактного класса.

            //---Отличия абстрактного класса от интерфейса---///

            1.  Абстрактный класс может иметь переменные экземпляра.
                Интерфейс может иметь только public static final поля (константы).

            2.  Любой класс может быть расширен только одним абстрактным классом.
                Любой класс может реализовать множество интерфейсов.

            3.  Абстрактный класс может иметь модификаторы доступа для методов и переменных.
                Все методы в интерфейсе являются неявно абстрактными и общедоступными.

        Интерфейсы широко используются в Java для определения контрактов и поведения.
        В то время как абстрактные классы предоставляют базовую реализацию для подклассов.
 */



    //--------------------------------------------------------------------------------------------------------------------//
//  Как сделать из обычного класса абстрактный класс не используя ключевое слово abstract?
//  Ответ: никак, но можно создать псевдоабстрактный класс:
    class PseudoAbstractClass {
        protected PseudoAbstractClass() {
            // Защищенный конструктор
        }

        protected void abstractMethod() {
            throw new UnsupportedOperationException("Должен быть переопределен в подклассе");
        }
    }


    //--------------------------------------------------------------------------------------------------------------------//
//  Как написать валидный код, который компилируется, в котором вы имплементите интерфейс в класс и не реализуете
//  в классе ни один из методов интерфейса, хотя все методы интерфейса абстрактные?
//  Ответ: да, но зачем?
    interface MyInterface {
        void myMethod();
    }
    abstract class MyClass implements MyInterface {
        // Не реализуем методы интерфейса здесь!
        // не наследуемся от класса
    }


    //--------------------------------------------------------------------------------------------------------------------//
//  Enum может имплементить интерфейс, в таком случае, он так же обязан реализовать все его методы.
//  Enum не может наследовать класс, т.к уже неявно наследует класс Enum
    enum MyEnum implements MyInterface{
        ;

        @Override
        public void myMethod() {
            // реализация метода
        }
    }


//--------------------------------------------------------------------------------------------------------------------//
//  Что такое Наследование, композиция, агрегирование
/*
    Наследование
    это концепция объектно-ориентированного программирования, которая позволяет одному классу (подклассу)
    наследовать характеристики (поля и методы) другого класса (родительского класса).
    Подкласс может использовать и расширять функциональность родительского класса, а также добавлять новые свойства
    и методы. Наследование поощряет повторное использование кода и способствует иерархической организации классов.

    Композиция
    это отношение между классами, когда один класс содержит другой в качестве части.
    Это означает, что экземпляры одного класса являются частью экземпляров другого класса
    и не могут существовать независимо.
    Композиция используется для создания более сложных объектов из более простых, при этом изменения во внутреннем
    классе могут влиять на внешний класс.

    Агрегирование
    это специальный вид композиции, где объекты одного класса могут содержать ссылки на объекты другого класса
    как часть своего состояния.
    В отличие от жесткой связи в композиции, объекты могут быть созданы и использованы независимо друг от друга.
 */


    //--------------------------------------------------------------------------------------------------------------------//
//  Переопределение метода.
//  Ковариантность типа возвращаемого значения?
/*
    Есть классы, например, "Фрукт" и "Яблоко".
    "Яблоко" является подтипом "Фрукта", потому что яблоко - это как особый вид фрукта.

    Представь, что у класса "Фрукт" есть метод, который возвращает фрукт.
    Когда мы создаем класс "Яблоко", мы можем переопределить этот метод так, чтобы он возвращал не просто фрукт,
    а именно яблоко. Это и есть ковариантность типа возвращаемого значения - мы можем вернуть более конкретный тип
    (яблоко) вместо более общего (фрукт), когда переопределяем метод.
 */
    class Fruit {
        public Fruit chtoEto () {
            return new Fruit();
        }
    }
    class Apple extends Fruit {
        public Apple chtoEto(){
            return new Apple();
        }
    }


//--------------------------------------------------------------------------------------------------------------------//
//  Что будет если передать массив в метод, который изменит его значения, изменятся ли они вне метода? Почему?
//  А если передать примитив?
/*
    Если вы передадите массив в метод и измените его значения внутри метода, то изменения будут отражены
    в изначальном массиве за пределами метода.
    Это происходит потому, что массивы в Java передаются по ссылке, что означает, что сама ссылка на массив передается
    в метод, а не его копия. Поэтому любые изменения, сделанные внутри метода, будут видны за его пределами.

    Если же вы передадите примитивный тип данных (такой, как int, double, char и т. д.) в метод, и измените его значение
    внутри метода, то эти изменения не будут отражены в изначальной переменной за пределами метода.
    Примитивные типы данных передаются по значению, поэтому метод получает только копию значения переменной,
    и любые изменения внутри метода не затронут изначальную переменную.

 */

//--------------------------------------------------------------------------------------------------------------------//
//  Что такое сокрытие методов - "method hiding"?
/*
    Этот термин обычно относится к ситуации, когда подкласс объявляет статический метод с тем же именем,
    что и унаследованный статический метод его суперкласса.
 */

//--------------------------------------------------------------------------------------------------------------------//
//  Где хранятся ссылки на объект?
/*
    Стек:
    В стеке хранятся локальные переменные и ссылки на объекты, которые являются частью выполнения конкретного метода.
    При вызове метода выделяется определенная область памяти для его локальных переменных и ссылок на объекты.
    Когда метод завершает выполнение, эта область памяти освобождается.

    Куча:
    Объекты в языках с управляемой памятью, как правило, размещаются в области памяти, называемой кучей (heap).
    Ссылки на объекты, хранящиеся в стеке, указывают на соответствующие объекты в куче.
    Куча используется для динамического выделения и освобождения памяти под объекты во время выполнения программы.
 */

//--------------------------------------------------------------------------------------------------------------------//
//  Что такое позднее и раннее связывание?
/*
    В Java, позднее и раннее связывание относятся к принципам, определяющим, каким образом выбирается и вызывается
    метод во время выполнения программы.

    Раннее связывание (статическое связывание):
    Раннее связывание связано с перегрузкой методов и определением методов и переменных на этапе компиляции.
    Когда вызывается перегруженный метод, компилятор определяет, какой именно метод будет вызван,
    на основе типов аргументов в момент компиляции.
    Это решение остается постоянным во время выполнения программы, что отражает статическую природу вызова метода.

    Позднее связывание (динамическое связывание):
    Позднее связывание связано с полиморфизмом и наследованием.
    При вызове метода по ссылке на объект, выбор конкретной реализации метода происходит во время выполнения,
    основываясь на реальном типе объекта в памяти.
    Это позволяет Java поддерживать полиморфизм, потому что конкретная реализация метода будет определена в зависимости
    от типа объекта, что делает вызов метода динамическим.
 */


    //--------------------------------------------------------------------------------------------------------------------//
//  Что такое varargs? Какие есть ограничения при написании?
/*
    Varargs (сокращение от "variable-length arguments") - это механизм, который позволяет методу принимать переменное
    количество аргументов определенного типа. Varargs обозначается тремя точками после типа данных аргумента
    в параметре метода.

    Ограничения при использовании varargs в Java:

    1.  Varargs должен быть последним параметром метода.
    Это означает, что каждый метод может иметь только один параметр varargs,
    и он должен быть последним в списке параметров.

    2. Varargs может иметь только один тип.
    Он не может быть многомерным или содержать элементы различных типов.
    Например, void method(String... strings, int... numbers) не допускается.

    3. Varargs может быть пустым. Если метод вызывается без аргументов, то varargs будет представлен пустым массивом,
    а не нулевым значением или null.
 */
    class someClass {
        public void printNumbers(int... numbers) {
            for (int number : numbers) {
                System.out.println(number);
            }
        }
    }

















}
